#!/usr/bin/perl
#--------------------------------------------------------------------------
# -*-perl-*-
#
# Copyright (C) 2004 Jörg Tiedemann  <joerg@stp.ling.uu.se>
#
# $Id$
#--------------------------------------------------------------------------
# USAGE: optimize bitext.ces bitext.gold [src-lang [trg-lang]]
#
#   bitext.ces ..... sentence alignment file a la XCES
#   bitext.gold .... gold standard for the same bitext
#   src-lang ....... source language id, e.g. 'sv' (optional)
#   trg-lang ....... source language id, e.g. 'en' (optional)
#
#--------------------------------------------------------------------------
# run lots of remote alignments
# config-files: uplug/systems/align/word/test/
#--------------------------------------------------------------------------
# this script
#   * creates word alignment clues
#         - basic clues
#         - giza clues                             (requires GIZA++)
#         - dynamic clues from time to time
#           (each time more than $LearnStep new 
#            scores have been counted)
#   * runs the clue aligner remotely               (requires remote-scripts)
#     (max $RunMax processes at a time)
#   * evaluates alignments using a gold standard
#   * collects scores
#   * modifies clue settings
#         - deletes clues          ($StartWithAllClues=1)
#         - adds clues             ($StartWithAllClues=0)
#         - changes clue weights   (if no other modification is possible or
#                                   $ModifyWeightsOnly=1)
#   * only the 10 best settings are kept and modified 
#     (can be changed: look at $Keepmax)
#
#--------------------------------------------------------------------------


use FindBin qw($Bin);
use strict;
use Cwd;
use File::Basename;

my $StartWithAllClues=0;  # =1 --> start with all available clues
my $ModifyWeightsOnly=0;  # =1 --> modify weights only (don't add/delete clues)
my $RunMax=30;            # max number of remote processes
my $KeepMax=10;           # keep the best KeepMax settings before modfiying
my $ClueWeightSteps=0.03; # steps for changing clue weights
my $LearnStep=30;         # how often to learn new dynamic clues
my $maxNotImpr=25;        # stop after a certain number of clue-learning
                          #     without any improvement
my $DefWeight=0.05;       # default weight for clues

#my $LearnStep=50000000;   # (basically don't do it ....)

########################################################################

my $srclang;
my $trglang;
if (@ARGV<2){
    die "\nusage: optimize corpus gold-standard [srclang [trglang]]\n\n";
}
my $corpus=shift @ARGV;
my $gold=shift @ARGV;
if (not -e $corpus){die "cannot find corpus '$corpus'!\n";}
if (not -e $gold){die "cannot find gold standard '$gold'!\n";}
if (@ARGV){$srclang=shift @ARGV;}
if (@ARGV){$trglang=shift @ARGV;}

########################################################################

my $thisdir=getcwd;
if (dirname($gold)!~/^\//){$gold="$thisdir/$gold";}
if (dirname($corpus)!~/^\//){$corpus="$thisdir/$corpus";}

my $UplugHome="$Bin/..";
my $uplug=$UplugHome.'/uplug';
my $LinkConfig='systems/align/word/test/link';
my $align=$uplug.' '.$LinkConfig;
my $eval=$UplugHome.'/bin/evalalign.pl';
my $summarize=$UplugHome.'tools/summarize-eval';
my $remote='/home/staff/joerg/bin/remote';

my @gizaclues=('giza-word-prefix',
	       'giza-word-prefix-i',
	       'giza-word',
	       'giza-word-i',
	       'giza-pos',
	       'giza-pos-i',
	       'giza-pos-word',
	       'giza-pos-word-i',
#	       'giza-word-prefix1',
#	       'giza-word-prefix2',
#	       'giza-word-prefix4',
	       'giza-word-suffix',
	       'giza-word-suffix-i'
	      );

my @dynclues=(
	      'dp',
#	      'dpp',
	      'dc',
	      'dx',
	      'dl',    # lex
	      'dlp',   # lex+pos
	      'dpx',   # pos+position
	      'dp3',   # pos-trigram
	      'dp3x',  # pos-trigram+position
	      'dc3',   # chunk-trigram
	      'dc3p',  # chunk-trigram+pos
	      'dc3x'   # chunk-trigram+position
	      );

my $dynpar=join (' 1 -',@dynclues);
my $dynamic="$uplug systems/align/word/dynamicclues -$dynpar 1";
my $DynNr;

my %StatAlignClues=(
		'dice'      => 'dice.dbm',
		'sim'       => 'str.dbm',
		'gw'        => 'giza-word.dbm',
		'gwi'       => 'giza-word-i.dbm',
		'gp'        => 'giza-pos.dbm',
		'gpi'       => 'giza-pos-i.dbm',
		'gpw'       => 'giza-pos-word.dbm',
		'gpwi'      => 'giza-pos-word-i.dbm',
		'gwp'       => 'giza-word-prefix.dbm',
		'gwpi'      => 'giza-word-prefix-i.dbm',
#		'gwp1'      => 'giza-word-prefix1.dbm',
#		'gwp2'      => 'giza-word-prefix2.dbm',
#		'gwp4'      => 'giza-word-prefix4.dbm',
		'gws'       => 'giza-word-suffix.dbm',
		'gwsi'       => 'giza-word-suffix-i.dbm'
		);

my %DynAlignClues=(
		'dp'     => 'pos.dbm',
#		'dpp'    => 'pos_coarse.dbm',
		'dc'     => 'chunk.dbm',
		'dx'     => 'position.dbm',
		'dl'     => 'lex.dbm',
		'dlp'    => 'lexpos.dbm',
		'dpx'    => 'posposi.dbm',
		'dp3'    => 'postri.dbm',
		'dp3x'   => 'postriposi.dbm',
		'dc3'    => 'chunktri.dbm',
		'dc3p'   => 'chunktripos.dbm',
		'dc3x'   => 'chunktriposi.dbm'
		);


#########################################################################
########################################################################

my $NrRunning=0;          # process counter
my $NrClueAlign=0;        # total number of alignment attempts

my @Setting;              # the set of settings
my %Running;              # running processes (indexed by filnames)
my %Tried;                # settings tried already (filenames)
my %Scores;               # scores
$Scores{F}={};

my $GoldSize=&GetGoldSize($gold);  # check the size of the gold standard

#########################################################################
#########################################################################

&MakeEstimatedClues();                       # estimate clues
my @AvailableClues=&GetAvailableClues();     # get available clues

if ($StartWithAllClues){
    &RunAllClues(\@Setting,\@AvailableClues);          # run with all clues
    for (2..$RunMax){                                  # make $RunMax copies
	push (@Setting,{});                            # of the base setting
	%{$Setting[-1]{clues}}=%{$Setting[-2]{clues}}; # (to be modified)
    }
}
else{
    &RunSingleClues(\@Setting,\@AvailableClues);   # run single clue settings
}

#----------------------------------------------------------------------

#########################################################################
#########################################################################
### this is the main loop ###############################################
#########################################################################
#########################################################################

my $bestScore=0;        # best F-score so far
my $countNotImpr=0;     # count number loops without any improvement
my $modified=0;         # number of modified settings
my $nextDyn=$LearnStep; # next time to learn clues from the best alignment


do {
    &GetBestSettings(\@Setting,$KeepMax);     # get the $KeepMax best results
    $modified=0;
    foreach (0..$#Setting){                 # try to modify existing settings
	if ($StartWithAllClues){
	    if ($ModifyWeightsOnly){
		if (&ModifyClueWeights($Setting[$_])){$modified++;}
	    }
	    else{
		if (&ModifySetting2($Setting[$_])){$modified++;}
	    }
	}
	else{
	    if ($ModifyWeightsOnly){
		if (&ModifyClueWeights($Setting[$_])){$modified++;}
	    }
	    else{
		if (&ModifySetting($Setting[$_])){$modified++;}
	    }
	}
    }
    if ($modified){                           # if there are any new settings
	&RunAllSettings(\@Setting);           # run them!
    }

    #--------------------------------------------------
    # learn dynamic clues from time to time
    # (if more than $nextDyn scores stored in the result-table)
    #    1) more than $LearnStep scores
    #    2) more than 2*$LearnStep scores
    #    3) more than 3*$LearnStep scores
    #    ....
    my $NrScores=keys %{$Scores{F}};
    if ($NrScores>$nextDyn){          # learn new dynamic clues
	$nextDyn+=$LearnStep;

	print "## top-list after $NrScores alignment runs (next=$nextDyn):\n";
	&PrintScores();
	my ($best)=sort {$Scores{F}{$b} <=> $Scores{F}{$a}} keys %{$Scores{F}};
	my $score=$Scores{F}{$best};                 # the best score so far
	if ($score>$bestScore){$bestScore=$score;}   # improved? yes!->save it!
	else{$countNotImpr++;}                       # no? -> increment counter
	if ($countNotImpr>$maxNotImpr){&FinishUp();} # ... enough! --> give up!

	if ($best and (not -e "$best.dyn")){                # don't do it twice
	    if (-e "$best.links.gz"){
		$DynNr++;                                   # increment counter
		print "learn dynamic clues from $best.links\n";
		my $thisdir=getcwd;                         # the current dir
		my $links="$thisdir/$best.links.gz";        # training data
		if (not -e 'dynamic'){mkdir 'dynamic';}     # training dir
		chdir 'dynamic';                            #   (go there)
		&MakeDynamicClues($links);                  # learn clues
		while (not -e "dyn$DynNr.ready"){sleep 1;}  # wait until ready
		unlink "dyn$DynNr.ready";
		chdir $thisdir;                             #   (go back)
		# wait until all alignment processes
		# using dynamic clues are finished
		# (this should be probably checked more carefully)
		while (&DynIsRunning){sleep 1;}
		# move dynamic clues
		# (overwrite old ones!!!)
		system ("mv dynamic/data/runtime/*dbm* data/runtime/");
		system ("touch $best.dyn");                 # create a flag

		if ($StartWithAllClues){                    # if StartWithAll:
		    &GetBestSettings(\@Setting,$KeepMax);   # get top results
		    foreach my $s (@Setting){               # add all clues
			&AllClueSetting($s);                #  to each setting
		    }                                       # and ...
		    &RunAllSettings(\@Setting);             #  ... run them!
#		    push (@Setting,{clues=>{}});            #  create a setting
#		    &AllClueSetting($Setting[-1]);          #  with all clues
		}
	    }
	}
    }
    # -----------------
    sleep 1;
}
until ((not $modified) and (not keys %Running));

#-------------------------------------------------------------
&FinishUp();  # wait until all running processes are finished
#-------------------------------------------------------------

exit;

#########################################################################
#########################################################################
### this is the end #####################################################
#########################################################################
#########################################################################





sub DynIsRunning{
    my @dynamic=keys %Running;
    @dynamic=grep (/^dyn/,@dynamic);
    foreach (@dynamic){
	if (-e "$_.links"){return 1;}
    }
    return 0;
}

sub FinishUp{
    my $running=scalar keys %Running;
    while ($running){
	$running=0;
	foreach my $r (keys %Running){
	    if (&CheckScore(\@Setting,$r)){
		$NrRunning--;
		delete $Running{$r};
	    }
	    elsif (-e "$r.links"){$running++;}
	}
	sleep 1;
    }
    foreach my $r (keys %Running){
	print "warn: failed to run $r\n!";
    }

    my $NrScores=keys %{$Scores{F}};
    print "## final top-list after $NrScores alignment runs:\n";
    &PrintScores();
}


#########################################################################
###### this is the end ##################################################
#########################################################################
#########################################################################






sub GetBestSettings{
    my $set=shift;
    my $max=shift;

##-----------------------------------------------------------
## wait for all currently running processes to be finished
## (comment this out if fast processes should be preferred!) 
# 
#    while (keys %Running){
	foreach my $r (keys %Running){
	    if (&CheckScore($set,$r)){
		$NrRunning--;
		delete $Running{$r};
	    }
	}
#	sleep 1;
#    }
##-----------------------------------------------------------

    my @best=sort {$Scores{F}{$b} <=> $Scores{F}{$a}} keys %{$Scores{F}};
    if ($#best<$max){return;}
    @{$set}=();
    my $count=0;
    while (@best){
	my $file=shift(@best);
	$count++;                       # count the number of settings
	if ($count>$max){               # keep only the $max best settings!
	    foreach (@best){            # remove all other link files:
		if (-e "$_.links.gz"){unlink "$_.links.gz";}
		if (-e "$_.links"){unlink "$_.links";}
	    }
	    return;
	}
	push(@{$set},{});
	&File2Setting($set->[-1],$file);
    }
}

###########################################################

sub RunSingleClues{
    my ($sets,$clues)=@_;
    while (@{$clues}){                              # create inital settings
	my $clue=shift(@{$clues});                  # foreach available clue
	push (@{$sets},{clues=>{$clue=>$DefWeight}, #   create settings with
			lastchange=>'+'.$clue,      #   single clues
			modified=>1});
    }
    &RunAllSettings($sets);                  # run all clue alignment settings
}

sub RunAllClues{
    my ($sets,$clues)=@_;
    push (@{$sets},{clues=>{}});
    &AllClueSetting($sets->[-1]);
    &RunAllSettings($sets);                  # run all clue alignment settings
}

###########################################################
# RunAllSettings
#
# check evaluation files first
# then run all settings in the settings-array


sub RunAllSettings{
    my $settings=shift;

    print "Running: ";
    print scalar keys %Running;
    print ", Scores: ";
    print scalar keys %{$Scores{F}};
    print ", NrClues: ";
    print scalar @AvailableClues;
    print ", NrClueAlign: $NrClueAlign, NrRunning: $NrRunning";
    #-----------------------------------------------
    do {
	if (keys %Running){
	    foreach my $r (keys %Running){
		if (&CheckScore($settings,$r)){
		    $NrRunning--;
		    delete $Running{$r};
		}
	    }
	}
	sleep 1;
    }
    until ($NrRunning<$RunMax);
    #-----------------------------------------------
#    print "running: ";
#    print scalar keys %Running;
    print " ($NrRunning)\n";
#    print "";


    foreach my $s (@{$settings}){
	if ($s->{modified}){
	    my $file=&Setting2File($s);
	    system "touch $file.ready";
	    if (&CheckScore($settings,$file)){next;}
	    unlink "$file.ready";
	    my $file=&RunClueAligner($s);
#	    $NrRunning++;
#	    $Running{$file}=$s->{lastchange};
	}
    }
    $NrRunning=scalar keys %Running;
}

###########################################################
# take all available clues!!!!

sub AllClueSetting{
    my $s=shift;

    my @AllClues=&GetAvailableClues();           # get all available clues
    @AvailableClues=@AllClues;
    foreach (@AllClues){                         # for all clue types
	if (not defined $s->{clues}->{$_}){      # if not included already:
	    $s->{clues}->{$_}=$DefWeight;        #   set default weight
	}
    }
    my $file=&Setting2File($s);          #   get the filebase
    if ((defined $Scores{F}{$file}) or   #   if tested already or
	(defined $Tried{$file})){        #   if already running:
	delete $s->{clues}->{$_};        #      don't try again
    }
    else{                                # otherwise:
	$s->{modified}=1;                #   give it a shot
	return 1;
    }
    return 0;
}


###########################################################
# modify clue alignment settings
# change clue weights ONLY!!!!!

sub ModifyClueWeights{
    my $s=shift;

    #----------------
    # check without modification
    # (might be ok if new dynamic clues exist!
    #----------------
    my $file=&Setting2File($s);           #   get the filebase
    if ((not defined $Scores{F}{$file})   #   if tested already or
	and (not defined $Tried{$file})){ #   if already running:
	$s->{modified}=1;                 #   give it a shot
	return 1;                         #   (mark as modified)
    }

    my $step=$ClueWeightSteps;
    my @clues=keys %{$s->{clues}};
    my $file;
    do {
	my $idx=int(rand $#clues+1);             # random index number
	my $clue=$clues[$idx];                   # (choose random clue)
	my $sign=-1;                             # decrease
	if (int(rand 2)){$sign=1;}               # or increase
	$s->{clues}->{$clue}+=$sign*$step;       # change the weight
	$s->{clues}->{$clue}=
	    (int(100*$s->{clues}->{$clue}))/100; 
	$file=&Setting2File($s);                 # convert to file base
    }
    until ((not defined $Scores{F}{$file})       # do this until a new setting
	   and (not defined $Tried{$file}));     # is found!

    $s->{modified}=1;                            # try it (mark as modified
    return 1;                                    #         and return)
}

# end of modify setting
###########################################################


###########################################################
# modify clue alignment settings (version 2)
#
# 1) delete available clues
# 2) change clue weights

sub ModifySetting2{
    my $s=shift;

    #----------------
    # check without modification
    # (might be ok if new dynamic clues exist!
    #----------------
    my $file=&Setting2File($s);           #   get the filebase
    if ((not defined $Scores{F}{$file})   #   if tested already or
	and (not defined $Tried{$file})){ #   if already running:
	$s->{modified}=1;                 #   give it a shot
	return 1;                         #   (mark as modified)
    }

    my @AllClues=&GetAvailableClues();           # get all available clues
    @AvailableClues=@AllClues;
##    foreach my $c (@AllClues){                   # for all clue types
    while (@AllClues){                           # as long as there are clues
	my $idx=int(rand $#AllClues+1);          # random index number
	my $c=splice(@AllClues,$idx,1);          # get/remove the clue
	if (defined $s->{clues}->{$c}){          # if included already:
	    my $weight=$s->{clues}->{$c};        #   save the weight
	    delete $s->{clues}->{$c};            #   delete the clue
	    my $file=&Setting2File($s);          #   get the filebase
	    if ((defined $Scores{F}{$file}) or   #   if tested already or
		(defined $Tried{$file})){        #   if already running:
		$s->{clues}->{$c}=$weight;       #   put it back again
	    }
	    else{                                # otherwise:
		$s->{modified}=1;                #   give it a shot
		return 1;                        #   (mark as modified)
	    }
	}
    }
    #-----------------------------
    # deleting clues didn't work
    #   --> try to change weights!
    #-----------------------------

    my $step=$ClueWeightSteps;
    my @clues=keys %{$s->{clues}};
    my $file;
    do {
	my $idx=int(rand $#clues+1);             # random index number
	my $clue=$clues[$idx];                   # (choose random clue)
	my $sign=-1;                             # decrease
	if (int(rand 2)){$sign=1;}               # or increase
	$s->{clues}->{$clue}+=$sign*$step;       # change the weight
	$s->{clues}->{$clue}=
	    (int(100*$s->{clues}->{$clue}))/100; 
	$file=&Setting2File($s);                 # convert to file base
    }
    until ((not defined $Scores{F}{$file})       # do this until a new setting
	   and (not defined $Tried{$file}));     # is found!

    $s->{modified}=1;                            # try it (mark as modified
    return 1;                                    #         and return)
}

# end of modify setting
###########################################################



###########################################################
# modify clue alignment settings
#
# 1) add available clues
# 2) change clue weights

sub ModifySetting{
    my $s=shift;

    #----------------
    # check without modification
    # (might be ok if new dynamic clues exist!
    #----------------
    my $file=&Setting2File($s);           #   get the filebase
    if ((not defined $Scores{F}{$file})   #   if tested already or
	and (not defined $Tried{$file})){ #   if already running:
	$s->{modified}=1;                 #   give it a shot
	return 1;                         #   (mark as modified)
    }

    my @AllClues=&GetAvailableClues();           # get all available clues
    @AvailableClues=@AllClues;
##    foreach my $c (@AllClues){                   # for all clue types
    while (@AllClues){                           # as long as there are clues
	my $idx=int(rand $#AllClues+1);          # random index number
	my $c=splice(@AllClues,$idx,1);          # get/remove the clue
	if (not defined $s->{clues}->{$c}){      # if not included already:
	    $s->{clues}->{$c}=$DefWeight;        #   set default weight
	    my $file=&Setting2File($s);          #   get the filebase
	    if ((defined $Scores{F}{$file}) or   #   if tested already or
		(defined $Tried{$file})){        #   if already running:
		delete $s->{clues}->{$c};        #      don't try again
	    }
	    else{                                # otherwise:
		$s->{modified}=1;                #   give it a shot
		return 1;                        #   (mark as modified)
	    }
	}
    }

    my $step=$ClueWeightSteps;
    my @clues=keys %{$s->{clues}};
    my $file;
    do {
	my $idx=int(rand $#clues+1);             # random index number
	my $clue=$clues[$idx];                   # (choose random clue)
	my $sign=-1;                             # decrease
	if (int(rand 2)){$sign=1;}               # or increase
	$s->{clues}->{$clue}+=$sign*$step;       # change the weight
	$s->{clues}->{$clue}=
	    (int(100*$s->{clues}->{$clue}))/100; 
	$file=&Setting2File($s);                 # convert to file base
    }
    until ((not defined $Scores{F}{$file})       # do this until a new setting
	   and (not defined $Tried{$file}));     # is found!

    $s->{modified}=1;                            # try it (mark as modified
    return 1;                                    #         and return)
}

# end of modify setting
###########################################################



###########################################################
# check scores:
#
# check if there's an eval-file with some scores
# save scores in the Score-hash
# restart the clue aligner if something went wrong

sub CheckScore{
    my $setting=shift;
    my $file=shift;
    if (-e "$file.ready" && -e "$file.eval"){
#    if (-e "$file.eval"){
	open (E, "$file.eval");
	my @link = <E>;
	close E;

	#-------------------------------------------------------
	# check the size of the evaluation file
	# and compare it to the size of the gold standard
	#   if they are not identical --> something went wrong
	#                             --> re-run the alignment!

	my ($size)=grep /size of gold standard/,@link;
	$size=~s/^.*size of gold standard:\s*([0-9]+)\,.*$/$1/;
	if ($size<$GoldSize){
	    if (-e "$file.links.gz"){unlink "$file.links.gz";}
	    if (-e "$file.links"){unlink "$file.links";}
	    unlink "$file.eval";                         # delete old eval-file
	    unlink "$file.ready";                        # delete ready-flag
	    delete $Running{$file};                      # delete from running
	    delete $Tried{$file};
	    delete $Scores{F}{$file};                    # delete scores
	    sleep 1;
	    push (@{$setting},{});
	    &File2Setting($setting->[-1],$file);
	    $setting->[-1]->{modified}=1;
	    &RunClueAligner($setting->[-1]);
	    return 0;
	}
	#-------------------------------------------------------

	if ($link[-1]=~/F:\s+([0-9]+\.[0-9]+)\%/){       # save the F-score
	    $Scores{F}{$file}=$1;
	    if ($link[-2]=~/precision:\s+([0-9]+\.[0-9]+)\%/){   # precision
		$Scores{P}{$file}=$1;
	    }
	    if ($link[-3]=~/recall:\s+([0-9]+\.[0-9]+)\%/){   # precision
		$Scores{R}{$file}=$1;
	    }
	    if (-e "$file.log"){
		open (L, "$file.log");
		my ($time) = grep {/processing time:/} <L>;
		close L;
		if ($time=~/processing time:\s*([0-9].*)$/){
		    $time=$1;
		    while ($time=~s/^\s*0:\s*//){};
		    $Scores{time}{$file}=$time;
		}
#		unlink "$file.log";
	    }
	    unlink "$file.ready";
	    return 1;
	}
    }
    return 0;
}

# end of CheckScores
###########################################################



###########################################################
# PrintScore: print the current score table

sub PrintScores{
    if (not keys %Scores){return;}
    print "----------------------------------------------------\n";
    printf "%5s  %5s  %5s %8s %s\n",'P','R','F','time','name';
    print "----------------------------------------------------\n";
    foreach (sort {$Scores{F}{$b} <=> $Scores{F}{$a}} keys %{$Scores{F}}){
	printf "%3.2f  %3.2f  %3.2f %8s %s\n",
	$Scores{P}{$_},$Scores{R}{$_},$Scores{F}{$_},$Scores{time}{$_},$_;
    }
    print "----------------------------------------------------\n";
}


###########################################################
# GetGoldSize: get the size of the gold standard

sub GetGoldSize{
    my $file=shift;
    open (G, $file);
    my @links = grep {/\<(wordLink|link)\s/} <G>;
    close G;
    my %uniq=();                   # there are some copies in some
    map ($uniq{$_}=1,@links);      # gold standard files --> count only
    return scalar keys %uniq;      # unique links!
#    return scalar @links;
}


###########################################################
# GetAvailableClues: get all available clues
#                    (check if dbm-files exist)

sub GetAvailableClues{
    my @avail=();
    foreach (keys %StatAlignClues){
	if (-e "data/runtime/$StatAlignClues{$_}"){
	    push (@avail,$_);
	}
    }
    foreach (keys %DynAlignClues){
	if (-e "data/runtime/$DynAlignClues{$_}"){
	    push (@avail,$_);
	}
    }
    if (defined $srclang && defined $trglang){
	if (open (C, "$UplugHome/$LinkConfig")){
	    my @config=<C>;
	    close C;
	    if (grep {/\'${srclang}${trglang}p\'/} @config){
		push (@avail,"${srclang}${trglang}p");
	    }
	    if (grep {/\'${srclang}${trglang}pp\'/} @config){
		push (@avail,"${srclang}${trglang}pp");
	    }
	    if (grep {/\'${srclang}${trglang}c\'/} @config){
		push (@avail,"${srclang}${trglang}c");
	    }
	}
    }
    return @avail;
}


########################################################################
########################################################################
########################################################################


sub MakeLinkSubDir{
    use File::Basename;
    my $links=shift;
    my $dir=$links;
#    $dir=~s/\.links.gz//;
#    $dir=uc($dir);
    mkdir $dir;
    my ($name,$path)=fileparse($links);
    link $links,"$dir/$name";
    return $dir;
}


#-------------------
# MakeClueLinks: link non-existing clues to data/runtime 
#                in a given sub-directory

sub MakeClueLinks{
    my $dir=shift;
    opendir(DIR, 'data/runtime');                  # make links to clues
    my @dbm = grep { /\.dbm/ } readdir(DIR);
    closedir DIR;
    mkdir "$dir/data";
    mkdir "$dir/data/runtime";
    foreach (@dbm){
	if (not -e "$dir/data/runtime/$_"){
	    link "data/runtime/$_","$dir/data/runtime/$_";
	}
    }
}






###########################################################
# RunClueAligner
#
#-------------------------------------------------------
# run clue aligner 
#    settings: a set of clues with weights
#-------------------------------------------------------

sub RunClueAligner{

    my $setting=shift;
    if (ref($setting->{clues}) ne 'HASH'){return;}

    my @clues=keys %{$setting->{clues}};
    my @weights=values %{$setting->{clues}};
    my $minscore=$setting->{score};

    my $param='';
    foreach (keys %{$setting->{clues}}){
#	$param.='-'.$_.' ';
	if ($setting->{clues}->{$_}){
	    $param.='-'.$_.' ';
	    $param.='-'.$_.'_w '.$setting->{clues}->{$_}.' ';
	}
    }
    if ($minscore){$param.=" -min $minscore";}

    my $file=&Setting2File($setting);

    my $comm="$align -in $corpus $param -out $file.links 2>$file.log";
    $comm.=";gzip -f $file.links";
    $comm.=";$eval -gold $gold -in $file.links.gz >$file.eval";
    $comm.=";touch $file.ready";

    $setting->{modified}=0;

    if ((-e "$file.links") or
	(-e "$file.eval") or
	(-e "$file.links.gz")){
	print "warning: clue alignment '$file' already in progress!!!!\n";
	return undef;
    }
    if (defined $Running{$file}){
#	print "warning: clue alignment '$file' already running!!!!\n";
	$Running{$file}=1;
	return undef;
    }
    if (defined $Tried{$file}){
        print "warning: clue alignment '$file' already tried earlier!!!!\n";
	$Tried{$file}=1;
        return undef;
    }
    if (defined $Scores{F}{$file}){
	print "warning: there is a score for clue alignment '$file'!!!!\n";
	$Tried{$file}=1;
	return undef;
    }
    $Running{$file}=1;
    $Tried{$file}=1;
    $NrClueAlign++;
#    print "run $file\n";
    system ("$remote '$comm'");
    return $file;
}

# end of RunClueAligner
###########################################################



###########################################################
# make a unique filename for a clue aligner setting

sub Setting2File{

    my $setting=shift;
    if (ref($setting->{clues}) ne 'HASH'){return undef;}
    my $file='C';         # start file names with 'C' (to avoid initial '-') 
    my $InclDynClue=0;
    foreach (sort keys %{$setting->{clues}}){
	if (defined $setting->{clues}->{$_}){          # weights before clues!
	    $file.=$setting->{clues}->{$_};
	}
	$file.=$_;                                     # clue name
	if (defined $DynAlignClues{$_}){$InclDynClue=1;}
	$file.='+';
    }
    chop ($file);
    if ($InclDynClue){$file='dyn'.$DynNr.'__'.$file;}  # add dynclue-marker
    my $minscore=$setting->{score};
    if ($minscore){$file.="_min$minscore";}
    return $file;
}


###########################################################
# create the clue aligner setting from a uniqe filename

sub File2Setting{

    my $setting=shift;
    my $file=shift;

    $file=~s/^.*?\_\_//;            # remove dynclue-marker
    $file=~s/^C//;                  # remove initial 'C'
    if ($file=~s/(\_min)(.*)$//){   # check if there's a score threshold
	$setting->{score}=$2;
    }
    my @clues=split(/\+/,$file);    # split into clues
    foreach (@clues){
	if (/^([0-9\.]*)([^0-9].*)$/){
	    $setting->{clues}->{$2}=$1;
	}
	else{
	    $setting->{clues}->{$_}=$DefWeight;
	}
    }
}


###########################################################
# MakeEstimatedClues
#
#------------------------------------------------
# create giza clues and basic clues
# and wait until they are finished
#------------------------------------------------


sub MakeEstimatedClues{

#------------------------------------------------
# run giza remotely

    print "create estimated clues!\n";
    foreach my $c (@gizaclues){
	if (-e "$c.eval"){
	    next;
	}
	my $comm="$uplug systems/align/word/test/$c -in $corpus -out $c.links";
	$comm.=";gzip -f $c.links;$eval -gold $gold -in $c.links.gz >$c.eval";
	system ("$remote '$comm'");
    }

#------------------------------------------------
# create basic clues (dice+sim)

    if ((not -e "data/runtime/str.dbm") or 
	(not -e "data/runtime/dice.dbm")){
	print "create basic clues!\n";
	system("$uplug systems/align/word/basicclues -in $corpus");
    }

#------------------------------------------------
# wait for the remote alignments (giza)

    foreach my $c (@gizaclues){
	print "waiting for $c.eval!\n";
	while (not -e "$c.eval"){sleep 1;}
    }
}



###########################################################
# MakeDynamicClues
#
#------------------------------------------------
# learn dynamic clues from some previous links
#------------------------------------------------

sub MakeDynamicClues{
    my $links=shift;
    my $comm="$dynamic -in $links >dyn$DynNr.out 2>dyn$DynNr.log";
    $comm.=";touch dyn$DynNr.ready;";
    system ("$remote '$comm'");
}



