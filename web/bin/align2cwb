#!/usr/bin/perl
#
# Copyright (C) 2004 Jörg Tiedemann  <joerg@stp.ling.uu.se>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
# $Id$
#
# usage: align-to-cwb SRCPOS TRGPOS [-s SRC] [-t TRG] [-c CORPUS] ALIGN
#
# convert sentence-aligned XCES to CWB align format
#    - creates cwb-align file
#
#    SRCPOS: sentence start&end positions of the original documents
#    TRGPOS: sentence start&end positions of the translation documents
#       SRC: source language (en,de,...), default=src
#       TRG: target language              default=trg
#    CORPUS: name of corpus (short form)  default=XX
#     ALIGN: XCES align file
#


use strict;
use FindBin qw($Bin);

my $srcPosFile=shift(@ARGV);
my $trgPosFile=shift(@ARGV);

die "cannot find source position file $srcPosFile" unless -e $srcPosFile;
die "cannot find target position file $trgPosFile" unless -e $trgPosFile;

my $SRC='src';
my $TRG='trg';
my $CORPUS='XX';

while ($ARGV[0]=~/^\-/){
    my $opt=shift(@ARGV);
    if ($opt eq '-s'){$SRC=shift(@ARGV);}
    elsif ($opt eq '-t'){$TRG=shift(@ARGV);}
    elsif ($opt eq '-c'){$CORPUS=shift(@ARGV);}
}


open ALG1,">$SRC$TRG.alg";
open ALG2,">$TRG$SRC.alg";

print ALG1 "$CORPUS$SRC\ts\t$CORPUS$TRG\ts\n";
print ALG2 "$CORPUS$TRG\ts\t$CORPUS$SRC\ts\n";


my %srcPos=();
my %trgPos=();

open F,"<$srcPosFile";
my $file;
while(<F>){
    chomp;
    if (/^\#\s+(\S+)\s*$/){
	$file=$1;
	next;
    }
    my ($id,$start,$end)=split(/\t/,$_);
    $srcPos{$file}{$id}{start}=$start;
    $srcPos{$file}{$id}{end}=$end;
}

open F,"<$trgPosFile";
while(<F>){
    chomp;
    if (/^\#\s+(\S+)\s*$/){
	$file=$1;
	next;
    }
    my ($id,$start,$end)=split(/\t/,$_);
    $trgPos{$file}{$id}{start}=$start;
    $trgPos{$file}{$id}{end}=$end;
}


print '';
while (my $ALIGN=shift(@ARGV)){

    if ($ALIGN=~/\.gz$/){
	open F,"gzip -cd <$ALIGN |";
    }
    else{
	open F,"<$ALIGN";
    }
    my ($srcdoc,$trgdoc);
    while(<F>){
	if (/fromDoc=\"([^\"]+)\"/){
	    $srcdoc=$1;
	}
	if (/toDoc=\"([^\"]+)\"/){
	    $trgdoc=$1;
	}
	if (/(sentLink|link)\s.*xtargets=\"([^\"]+)\;([^\"]+)\"/){
	    my $src=$2;
	    my $trg=$3;
	    my @srcsent=split(/\s/,$src);
	    my @trgsent=split(/\s/,$trg);

	    if (not (@srcsent and @trgsent)){next;}
	    if (not defined $srcPos{$srcdoc}){next;}
	    if (not defined $srcPos{$srcdoc}{$srcsent[0]}){next;}
	    if (not defined $srcPos{$srcdoc}{$srcsent[-1]}){next;}
	    if (not defined $trgPos{$trgdoc}){next;}
	    if (not defined $trgPos{$trgdoc}{$trgsent[0]}){next;}
	    if (not defined $trgPos{$trgdoc}{$trgsent[-1]}){next;}

	#------------------------------------------
	# print alignment file (src --> trg)

	    print ALG1 $srcPos{$srcdoc}{$srcsent[0]}{start},"\t";
	    print ALG1 $srcPos{$srcdoc}{$srcsent[-1]}{end},"\t";
	    print ALG1 $trgPos{$trgdoc}{$trgsent[0]}{start},"\t";
	    print ALG1 $trgPos{$trgdoc}{$trgsent[-1]}{end},"\t";
	    print ALG1 scalar @srcsent;
	    print ALG1 ':';
	    print ALG1 scalar @trgsent;
	    print ALG1 "\n";

	#------------------------------------------
	# print alignment file (trg --> src)

	    print ALG2 $trgPos{$trgdoc}{$trgsent[0]}{start},"\t";
	    print ALG2 $trgPos{$trgdoc}{$trgsent[-1]}{end},"\t";
	    print ALG2 $srcPos{$srcdoc}{$srcsent[0]}{start},"\t";
	    print ALG2 $srcPos{$srcdoc}{$srcsent[-1]}{end},"\t";
	    print ALG2 scalar @trgsent;
	    print ALG2 ':';
	    print ALG2 scalar @srcsent;
	    print ALG2 "\n";
	}
    }
    close F;
}

close ALG1;
close ALG2;
