///////////////////////////////////////////////////////////////////////////////
// Copyright (C) 2000 Jason Baldridge and Gann Bierner
// 
// This program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public License
// as published by the Free Software Foundation; either version 2
// of the License, or (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
//////////////////////////////////////////////////////////////////////////////

package quipu.grok.ml.dectree;

import java.io.*;
import java.util.*;
import com.metamata.parse.*;

/**
 * Reads a decision tree produced by Ripper (a dtree generator) into
 * our internal data structure.
 *
 * @author      Gann Bierner
 * @version $Revision$, $Date$
 */
public grammar class RipperReader {

    public static DecisionTree parse(Reader r) {
	try{
	    initializeStaticParser(r);
	    return dtree();
	} catch(ParseException E) {
	    E.printStackTrace();
	}
	return null;
    }
    
    public static void main(String args[]) throws IOException {
	String infile = args[0];
	String outfile = args[1];

	FileOutputStream ostream = new FileOutputStream(outfile);
	ObjectOutputStream p = new ObjectOutputStream(ostream);

	p.writeObject(parse(new FileReader(infile)));
    }
    
    skip { " " | "\t" | "\r" | "\n" }

    token {
  	  < IF: "IF" >
	| < TEXT: (['(','+','-','a'-'z','A'-'Z'])+(~['\t',' ','\n'])* > 
	| < NUM:  (['0'-'9'])+ | (['0'-'9'])*"."(['0'-'9'])+ >
        | < OP: "="|"<"|"<="|">"|">=" >
    }

    static public production DecisionTree dtree() {
	{ List l; }
	l=rulelist() "." {
	    return new DecisionTree(l);
	}
    }

    static private production LinkedList rulelist() {
	{ LinkedList l=null; DTreeRule rule;}
	rule=rule() [ l=rulelist() ] {
	    if(l==null)
		l=new LinkedList();
	    l.addFirst(rule);
	    return l;
	}
    }

    static private production DTreeRule rule() {
	{
	    Token result;
	    List condList=null;
	}
	result=<TEXT> <NUM> <NUM> <IF> [condList=condlist()] "." {
	    return new DTreeRule(result.image, condList);
	}
    }

    static private production LinkedList condlist() {
	{ LinkedList l=null; DTreeCondition cond;}
	cond=condition() [ l=condlist() ] {
	    if(l==null)
		l=new LinkedList();
	    l.addFirst(cond);
	    return l;
	}
    }

    static private production DTreeCondition condition() {
	{ Token feature, op, val; }
	(
	  lookahead(3)
	  feature=<TEXT> <OP> val=<TEXT> {
	    return new DTreeSymbolCondition(feature.image, val.image);
	  }
	 |
	  feature=<TEXT> op=<OP> val=<NUM> {
	    return new DTreeContinuousCondition(feature.image,
						op.image,
						new Double(val.image));
	  }
       )
    }
}
